<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Flower Liner WebAR</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui,-apple-system;}
    #startScreen{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:10px;background:#000;color:#fff;z-index:50;}
    button{padding:10px 18px;border:none;border-radius:14px;background:#29b6f6;color:#012;font-size:16px;font-weight:600;}
    #ios-cam{position:fixed;inset:0;width:100%;height:100%;object-fit:cover;display:none;background:#000;}
    #ui{position:fixed;left:0;right:0;bottom:0;display:none;gap:6px;flex-wrap:wrap;justify-content:center;background:rgba(0,0,0,.35);padding:10px;z-index:20;}
    .btn{padding:6px 10px;border:none;border-radius:10px;background:rgba(255,255,255,.9);font-size:13px;}
  </style>
</head>
<body>
  <div id="startScreen">
    <h1>フラワー長井線 WebAR</h1>
    <button id="startBtn">開始する</button>
    <p>iPhoneはカメラ背景・Androidは床検出で動作します。</p>
  </div>
  <video id="ios-cam" autoplay playsinline muted></video>
  <div id="ui">
    <button class="btn" data-act="up">↑</button>
    <button class="btn" data-act="down">↓</button>
    <button class="btn" data-act="left">←</button>
    <button class="btn" data-act="right">→</button>
    <button class="btn" data-act="near">手前</button>
    <button class="btn" data-act="far">奥</button>
    <button class="btn" data-act="rotL">⟲</button>
    <button class="btn" data-act="rotR">⟳</button>
  </div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.159.0/build/three.module.js";
import {GLTFLoader} from "https://unpkg.com/three@0.159.0/examples/jsm/loaders/GLTFLoader.js";
import {ARButton} from "https://unpkg.com/three@0.159.0/examples/jsm/webxr/ARButton.js";

const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
const startBtn = document.getElementById('startBtn');
startBtn.addEventListener('click', ()=>{ document.getElementById('startScreen').remove(); isIOS ? startIOS() : startXR(); });

/* ========== 共通ユーティリティ：画面に収まるよう自動スケール ========== */
function fitModelToScreen(model, camera, renderer, margin=0.8){
  const box = new THREE.Box3().setFromObject(model);
  const size = new THREE.Vector3();
  box.getSize(size);
  const center = new THREE.Vector3();
  box.getCenter(center);
  model.position.sub(center);
  const distance = 2;
  camera.position.set(0,0,distance);
  const fov = camera.fov * (Math.PI / 180);
  const visibleHeight = 2 * Math.tan(fov / 2) * distance;
  const visibleWidth  = visibleHeight * (renderer.domElement.clientWidth / renderer.domElement.clientHeight);
  const scale = (visibleHeight * margin) / size.y;
  model.scale.set(scale, scale, scale);
}

/* ========== iOS: カメラ背景 + UI移動 ========== */
async function startIOS(){
  const video = document.getElementById('ios-cam');
  const ui = document.getElementById('ui');
  video.style.display = 'block';
  ui.style.display = 'flex';

  const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
  video.srcObject = stream;

  const renderer = new THREE.WebGLRenderer({alpha:true, antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.domElement.style.position="fixed";
  renderer.domElement.style.inset=0;
  renderer.domElement.style.pointerEvents="none";
  document.body.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 100);
  camera.position.set(0,0,5);
  scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));

  const loader = new GLTFLoader();
  let train = null;
  loader.load("./AR-Train_Nagai.glb", gltf=>{
    train = gltf.scene;
    scene.add(train);
    fitModelToScreen(train, camera, renderer, 0.8);
  });

  const s={x:0,y:-0.5,z:0,r:0};
  ui.addEventListener('click',e=>{
    const a=e.target.dataset.act;if(!a)return;
    switch(a){
      case'up':s.y+=.1;break;case'down':s.y-=.1;break;
      case'left':s.x-=.1;break;case'right':s.x+=.1;break;
      case'near':s.z+=.1;break;case'far':s.z-=.1;break;
      case'rotL':s.r+=.1;break;case'rotR':s.r-=.1;break;
    }
  });

  function render(){
    requestAnimationFrame(render);
    if(train){train.position.set(s.x,s.y,s.z);train.rotation.y=s.r;}
    renderer.render(scene,camera);
  }
  render();
}

/* ========== Android: WebXR床検出 ========== */
async function startXR(){
  const renderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
  renderer.setSize(innerWidth,innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera();
  scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));

  const btn = ARButton.createButton(renderer,{requiredFeatures:['hit-test']});
  btn.style.display='none';
  document.body.appendChild(btn);
  btn.click();

  const loader = new GLTFLoader();
  let train=null;
  loader.load("./AR-Train_Nagai.glb",g=>{
    train=g.scene;
    train.visible=false;
    scene.add(train);
  });

  const reticle = new THREE.Mesh(
    new THREE.RingGeometry(0.08,0.12,32).rotateX(-Math.PI/2),
    new THREE.MeshBasicMaterial({color:0x00ff99})
  );
  reticle.visible=false;reticle.matrixAutoUpdate=false;scene.add(reticle);

  let hitSource=null,hitReq=false;
  const clock=new THREE.Clock();

  renderer.setAnimationLoop((t,frame)=>{
    const dt=clock.getDelta();
    const s=renderer.xr.getSession();
    if(s&&!hitReq){
      s.requestReferenceSpace('viewer').then(sp=>{
        s.requestHitTestSource({space:sp}).then(src=>{hitSource=src;});
      });
      s.addEventListener('end',()=>{hitReq=false;hitSource=null;});
      hitReq=true;
    }
    if(frame&&hitSource){
      const sp=renderer.xr.getReferenceSpace();
      const hits=frame.getHitTestResults(hitSource);
      if(hits.length){
        const pose=hits[0].getPose(sp);
        reticle.visible=true;
        reticle.matrix.fromArray(pose.transform.matrix);
        renderer.domElement.onclick=()=>{
          if(train){
            train.visible=true;
            train.position.set(pose.transform.position.x,pose.transform.position.y,pose.transform.position.z);
            fitModelToScreen(train, camera, renderer, 0.5);
          }
        };
      }else reticle.visible=false;
    }
    if(train&&train.visible){train.rotateY(0.5*dt);}
    renderer.render(scene,camera);
  });
}
</script>
</body>
</html>
